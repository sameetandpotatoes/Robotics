#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    statusPort,     sensorAnalog)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalIn)
#pragma config(Sensor, dgtl2,  shaftEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  pneuVal,        sensorDigitalOut)
#pragma config(Sensor, dgtl5,  armLimit,       sensorDigitalIn)
#pragma config(Sensor, dgtl6,  btnLiftLimit,   sensorDigitalIn)
#pragma config(Sensor, dgtl11, disableAut,     sensorDigitalIn)
#pragma config(Sensor, dgtl12, nextToSection,  sensorDigitalIn)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port6,           liftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           arm,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)

#include "VEX_Competition_Includes.c"

//Function Declarations
void returnLiftToGround();
void turnMotors(int direction);
void verticalMotors(int direction);
void sideMotors(int direction);
void stopDrive();
void moveArmToPreload(int armSpeed);
void moveArmToScore(int armSpeed);
void toggleClamp();
void elevateLift(int height);
void returnLiftToPreload();
void liftMotors(int direction);
void stopLift();
int speedArm = 65;
float accelValue = 0.05;
bool clampOpen = true;
int direction = 1;
void pre_auton(){
}
task autonomous(){
	/* Clamp starts out closed */
	SensorValue[pneuVal] = 0;

	//If we are on the blue side, preload and scoring are switched
	//To fix this, switch the direction of armSpeed
	if (SensorValue[nextToSection] == 0){
		//Switch direction so preload is now on the other side and we can use the same code
		//speedArm = -speedArm;
		direction = -1;
	}
	writeDebugStreamLine("%d", direction);
	int lengthOfWait = 150;
	//if (!SensorValue[disableAut]){
			int scoredSections = 0;
			bool firstTime = true;
			while(scoredSections < 7){
				if (firstTime){
					//Release the arm only on the first time

					//Open the clamp
					//Raise the lift slightly to expand arm

					liftMotors(1);
					wait1Msec(700);
					toggleClamp();
					wait1Msec(100);
					stopLift();
				}
				//Move arm to pick up section
				moveArmToPreload(direction * speedArm);
				wait1Msec(lengthOfWait);
				//Close clamp on section
				toggleClamp();

				//Start lifting process
				//This needs to be our '0' spot so we come back to here
				SensorValue[shaftEncoder] = 0;
				//Regression Quadratic Equation
				int calculatedHeight;
				if (firstTime){
					calculatedHeight = 235;
				} else{
					calculatedHeight = (285.0 * scoredSections) + 85.33;
				}
				elevateLift(calculatedHeight);

				//Scoring
				moveArmToScore(direction * -70);
				wait1Msec(150);
				int nestValue = (firstTime) ? -275 : (int) (-867/7);
				elevateLift(nestValue);
				wait1Msec(500);
				toggleClamp();
				int clearValue = (firstTime) ? 150 : 180;
				firstTime = false;
				elevateLift(clearValue);

				//Return to starting position
				motor[arm] = direction * speedArm;
				wait1Msec(250);
				motor[arm] = 0;
				returnLiftToPreload();
				//int tempSpeed = (direction == 1) ? (speedArm + 15) : (speedArm - 15);
				moveArmToPreload(speedArm - 15);
				wait1Msec(lengthOfWait);
				//OR elevateLift(-calculatedHeight)

				scoredSections++;
			}
	//}
}
task usercontrol(){
	bool buttonJammed = false;
	//int debounceDelay = 400;
	//clearTimer(T1);
	while (true){
		//Get the drive values from the joystick
		int strafeY = vexRT[Ch1];
		int strafeX = vexRT[Ch3];
		int rotate = -vexRT[Ch4];

		//Map joystick values to each of the drive motors
		motor[backRight] 	= (strafeY - rotate + strafeX);
		motor[backLeft] 	= (strafeY + rotate - strafeX);
		motor[frontRight] = (strafeY - rotate - strafeX);
		motor[frontLeft] 	= (strafeY + rotate + strafeX);

		//Pneumatics
		//if (time1[T1] > debounceDelay){
			SensorValue[pneuVal] = (vexRT[Btn7U]) ? 1:
														(vexRT[Btn7D]) ? 0 : SensorValue[pneuVal];
		//	clearTimer(T1);
		//}
		//Lift Control
		motor[liftLeft] =
			((vexRT[Btn6D] && SensorValue[btnLiftLimit]) || (vexRT[Btn6D] && buttonJammed)) ? 127 :
			(vexRT[Btn6U]) ? -127 : 0;

		motor[liftRight] =
			((vexRT[Btn6D] && SensorValue[btnLiftLimit]) || (vexRT[Btn6U] && buttonJammed)) ? -127 :
			(vexRT[Btn6U]) ? 127 : 0;

		//Arm
		motor[arm] =
			(vexRT[Btn5U]) ? (speedArm) :
			(vexRT[Btn5D]) ? (-speedArm) : 0;

		if (vexRT[Btn8D] && !buttonJammed){
			returnLiftToGround();
		}

		//Second controller stuff - just lift and arm and pneumatics

		//motor[liftLeft] =
		//	((vexRT[Btn6DXmtr2] && SensorValue[btnLiftLimit]) || (vexRT[Btn6DXmtr2] && buttonJammed)) ? 127 :
		//	(vexRT[Btn6UXmtr2]) ? -127 : 0;

		//motor[liftRight] =
		//	((vexRT[Btn6DXmtr2] && SensorValue[btnLiftLimit]) || (vexRT[Btn6D] && buttonJammed)) ? -127 :
		//	(vexRT[Btn6UXmtr2]) ? 127 : 0;

		//Arm
		//motor[arm] = vexRT[Ch3Xmtr2];
		//motor[arm] =
		//	(vexRT[Btn5UXmtr2]) ? (speedArm) :
		//	(vexRT[Btn5DXmtr2]) ? (-speedArm) : 0;

		//if (time1[T1] < debounceDelay){
			//SensorValue[pneuVal] = (vexRT[Btn7UXmtr2]) ? 1 :
			//	(vexRT[Btn7DXmtr2]) ? 1 - SensorValue[pneuVal] : SensorValue[pneuVal];
		//	clearTimer(T1);
		//}
		buttonJammed = (vexRT[Btn7L]) ? !buttonJammed : buttonJammed;
	}
}
//Uses the button sensor
void returnLiftToGround(){
	while (SensorValue[btnLiftLimit]){
		liftMotors(-1);
	}
	stopLift();
}
//Activates the motors required to rotate robot
//@param direction: 1 is clockwise, -1 is counterclockwise
void turnMotors(int direction){
	motor[frontLeft] = -1 * direction * 127;
	motor[frontRight] = -1 * direction * 127;
	motor[backLeft] = direction * 127;
	motor[backRight] = direction * 127;
}
//Activates the motors required for vertical motion
//@param direciton: 1 is forward, -1 is backward
void verticalMotors(int direction){
	motor[frontLeft] = direction * 127;
	motor[frontRight] = -1 * direction * 127;
	motor[backLeft] = -1 * direction * 127;
	motor[backRight] = direction * 127;
}
//Activates the motors required to strafe robot
//@param direction: 1 is right, -1 is left
void sideMotors(int direction){
	motor[frontLeft] = -1 * direction * 127;
	motor[frontRight] = direction * 127;
	motor[backLeft] = direction * 127;
	motor[backRight] = -1 * direction * 127;
}
//Stops all motors associated with the drive
void stopDrive(){
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}
//Moves the arm to the preload side
void moveArmToPreload(int armSpeed){
	motor[arm] = armSpeed;
	wait1Msec(750);
	while (SensorValue[armLimit]){
		if (armSpeed > -100){
			motor[arm] = armSpeed;
			armSpeed -= -0.05;
		}else{
			motor[arm] = -100;
		}
		//accelerate(armSpeed, 90);
	}
	wait1Msec(250);
	motor[arm] = 0;
}
//Moves the arm to the scoring side
void moveArmToScore(int armSpeed){
	motor[arm] = armSpeed;
	wait1Msec(250);
	while (SensorValue[armLimit]){
		//if (armSpeed > -60){
		//	motor[arm] = armSpeed;
		//	armSpeed += accelValue;
		//} else{
		//	motor[arm] = -60;
		//}
		motor[arm] = armSpeed;
		//motor[arm] = armSpeed;
	}
	motor[arm] = armSpeed;
	wait1Msec(750);
	motor[arm] = 0;
}
//Toggles the clamp open and close
void toggleClamp(){
	SensorValue[pneuVal] =
			(clampOpen) ? 1 : 0;
	clampOpen = !clampOpen;
}
//Raises or lowers the lift by a certain change in height,
//measured with the shaft encoder
void elevateLift(int height){
	height *= -1;
	int target = SensorValue[shaftEncoder] + height;
	if (height < 0){
		while (SensorValue[shaftEncoder] > target){
			liftMotors(1);
		}
		stopLift();
	} else {
		while (SensorValue[shaftEncoder] < target){
			liftMotors(-1);
		}
		stopLift();
	}
	stopLift();
}
//Returns the lift back until shaft encoder count is 0
//Requires "ground" position to be 0 for this to work!
void returnLiftToPreload(){
	while (abs(SensorValue[shaftEncoder]) > 30){
		liftMotors(-1);
	}
	stopLift();
}
//Activates the motors required for the lift
//@param direction: 1 is up, -1 is down
void liftMotors(int direction){
	motor[liftLeft] = -1 * direction * 127;
	motor[liftRight] = direction  * 127;
}
//Stops all motors associated with the lift
void stopLift(){
	motor[liftLeft] = 0;
	motor[liftRight] = 0;
}
